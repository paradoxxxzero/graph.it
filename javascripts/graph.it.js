// Generated by CoffeeScript 1.6.3
var GraphIt, box_size, increment, key, make_line_box, make_plot, make_vertices, precision, region, sign, _i, _len, _ref,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  _this = this;

sign = function(x) {
  if (x < 0) {
    return -1;
  } else {
    return 1;
  }
};

make_vertices = function(vertices) {
  return vertices.map(function(v) {
    return new THREE.Vector3(v[0], v[1], v[2]);
  });
};

box_size = 100;

increment = box_size * .01;

precision = 100;

region = {
  x: [-5, 5],
  y: [-5, 5],
  z: [-25, 25]
};

make_line_box = function(h, color) {
  var geometry, material, type;
  geometry = new THREE.Geometry();
  h *= .5;
  geometry.vertices = make_vertices([[-h, -h, -h], [-h, h, -h], [-h, h, -h], [h, h, -h], [h, h, -h], [h, -h, -h], [h, -h, -h], [-h, -h, -h], [-h, -h, h], [-h, h, h], [-h, h, h], [h, h, h], [h, h, h], [h, -h, h], [h, -h, h], [-h, -h, h], [-h, -h, -h], [-h, -h, h], [-h, h, -h], [-h, h, h], [h, h, -h], [h, h, h], [h, -h, -h], [h, -h, h]]);
  geometry.computeLineDistances();
  material = new THREE.LineBasicMaterial({
    color: color
  });
  type = THREE.LinePieces;
  return new THREE.Line(geometry, material, type);
};

make_plot = function(color) {
  var geometry, material, mesh;
  geometry = new THREE.PlaneGeometry(box_size, box_size, precision, precision);
  geometry.dynamic = true;
  material = new THREE.MeshPhongMaterial({
    color: color,
    side: THREE.DoubleSide,
    specular: color,
    shininess: 10,
    vertexColors: THREE.FaceColors,
    metal: true
  });
  mesh = new THREE.Mesh(geometry, material);
  return mesh;
};

GraphIt = (function() {
  function GraphIt() {
    this.input = __bind(this.input, this);
    this.apply_fun = __bind(this.apply_fun, this);
    this.animate = __bind(this.animate, this);
    var _this = this;
    this.camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, box_size * 10);
    this.camera.position.z = 2.5 * box_size;
    this.fun = function(x, y) {
      return 0;
    };
    this.controls = new THREE.TrackballControls(this.camera);
    this.scene = new THREE.Scene();
    this.line = make_line_box(box_size, 0x5e3fbe);
    this.scene.add(this.line);
    this.plot = make_plot(0xff5995);
    this.scene.add(this.plot);
    this.hemi_light = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
    this.hemi_light.color.setHSL(0.6, 1, 0.6);
    this.hemi_light.groundColor.setHSL(0.095, 1, 0.75);
    this.hemi_light.position.set(0, 0, -500);
    this.scene.add(this.hemi_light);
    this.point_light = new THREE.PointLight(0xffffff, 1, 500);
    this.point_light.position = this.camera.position;
    this.scene.add(this.point_light);
    this.renderer = new THREE.WebGLRenderer({
      antialias: true
    });
    this.renderer.setClearColor(0x1b1d1e);
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.gammaInput = true;
    this.renderer.gammaOutput = true;
    this.controls.addEventListener('change', function() {
      return _this.renderer.render(_this.scene, _this.camera);
    });
    document.body.appendChild(this.renderer.domElement);
  }

  GraphIt.prototype.animate = function() {
    requestAnimationFrame(this.animate);
    window.t = ((new Date()).getTime() - window.base_time) / 1000;
    if (this.dirty && this.apply_fun()) {
      this.plot.geometry.computeCentroids();
      this.plot.geometry.computeFaceNormals();
      this.plot.geometry.computeVertexNormals();
      this.plot.geometry.normalsNeedUpdate = true;
      this.plot.geometry.verticesNeedUpdate = true;
      this.renderer.render(this.scene, this.camera);
    } else {
      this.dirty = false;
    }
    return this.controls.update();
  };

  GraphIt.prototype.apply_fun = function() {
    var delta, dirty, v, vz, x, y, z, _i, _len, _ref;
    dirty = false;
    _ref = this.plot.geometry.vertices;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      v = _ref[_i];
      x = v.x * (region.x[1] - region.x[0]) / box_size;
      y = v.y * (region.y[1] - region.y[0]) / box_size;
      z = this.fun(x, y);
      vz = z * box_size / (region.z[1] - region.z[0]);
      delta = v.z - vz;
      if (abs(delta) > increment) {
        dirty = true;
        v.z -= sign(delta) * increment;
      } else if (v.z !== vz) {
        dirty = true;
        v.z = vz;
      }
    }
    return dirty;
  };

  GraphIt.prototype.input = function(event) {
    var fun, rv;
    if (event.target.value === '') {
      return;
    }
    try {
      fun = new Function('x', 'y', 'return ' + event.target.value);
      rv = fun(0, 0);
    } catch (_error) {
      return;
    }
    if (typeof rv === 'number') {
      window.base_time = (new Date()).getTime();
      this.fun = fun;
      return this.dirty = true;
    }
  };

  return GraphIt;

})();

$(function() {
  _this.git = new GraphIt();
  _this.git.animate();
  $('input').on('input', git.input).focus().trigger('input');
  return $(window).resize(function() {
    _this.git.camera.aspect = window.innerWidth / window.innerHeight;
    _this.git.renderer.setSize(window.innerWidth, window.innerHeight);
    _this.git.camera.updateProjectionMatrix();
    return _this.git.controls.handleResize();
  });
});

_ref = ['abs', 'acos', 'asin', 'atan', 'atan2', 'ceil', 'cos', 'exp', 'floor', 'log', 'max', 'min', 'pow', 'random', 'round', 'sin', 'sqrt', 'tan', 'E', 'LN2', 'LN10', 'LOG2E', 'LOG10E', 'PI', 'SQRT1_2', 'SQRT2'];
for (_i = 0, _len = _ref.length; _i < _len; _i++) {
  key = _ref[_i];
  window[key.toLowerCase()] = Math[key];
}
